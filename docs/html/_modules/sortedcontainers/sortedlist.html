<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sortedcontainers.sortedlist &#8212; pyStim 1.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pyStim 1.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sortedcontainers.sortedlist</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Sorted list implementation.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># pylint: disable=redefined-builtin, ungrouped-imports</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>

<span class="kn">from</span> <span class="nn">bisect</span> <span class="k">import</span> <span class="n">bisect_left</span><span class="p">,</span> <span class="n">bisect_right</span><span class="p">,</span> <span class="n">insort</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">MutableSequence</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">repeat</span><span class="p">,</span> <span class="n">starmap</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">log</span> <span class="k">as</span> <span class="n">log_e</span>
<span class="kn">import</span> <span class="nn">operator</span> <span class="k">as</span> <span class="nn">op</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">iadd</span><span class="p">,</span> <span class="n">add</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">hexversion</span>

<span class="k">if</span> <span class="n">hexversion</span> <span class="o">&lt;</span> <span class="mh">0x03000000</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">izip</span> <span class="k">as</span> <span class="nb">zip</span>
    <span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">imap</span> <span class="k">as</span> <span class="nb">map</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">thread</span> <span class="k">import</span> <span class="n">get_ident</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">dummy_thread</span> <span class="k">import</span> <span class="n">get_ident</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">_thread</span> <span class="k">import</span> <span class="n">get_ident</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">_dummy_thread</span> <span class="k">import</span> <span class="n">get_ident</span> <span class="c1"># pylint: disable=import-error</span>

<span class="k">def</span> <span class="nf">recursive_repr</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorator to prevent infinite repr recursion.&quot;&quot;&quot;</span>
    <span class="n">repr_running</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return ellipsis on recursive re-entry to function.&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">get_ident</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">repr_running</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;...&#39;</span>

        <span class="n">repr_running</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">repr_running</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>

<span class="k">class</span> <span class="nc">SortedList</span><span class="p">(</span><span class="n">MutableSequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SortedList provides most of the same methods as a list but keeps the items</span>
<span class="sd">    in sorted order.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">load</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SortedList provides most of the same methods as a list but keeps the</span>
<span class="sd">        items in sorted order.</span>

<span class="sd">        An optional *iterable* provides an initial series of items to populate</span>
<span class="sd">        the SortedList.</span>

<span class="sd">        An optional *load* specifies the load-factor of the list. The default</span>
<span class="sd">        load factor of &#39;1000&#39; works well for lists from tens to tens of millions</span>
<span class="sd">        of elements.  Good practice is to use a value that is the cube root of</span>
<span class="sd">        the list size.  With billions of elements, the best load factor depends</span>
<span class="sd">        on your usage.  It&#39;s best to leave the load factor at the default until</span>
<span class="sd">        you start benchmarking.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">=</span> <span class="n">load</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_twice</span> <span class="o">=</span> <span class="n">load</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_half</span> <span class="o">=</span> <span class="n">load</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">iterable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">iterable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">load</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SortedList provides most of the same methods as a list but keeps the</span>
<span class="sd">        items in sorted order.</span>

<span class="sd">        An optional *iterable* provides an initial series of items to populate</span>
<span class="sd">        the SortedList.</span>

<span class="sd">        An optional *key* argument will return an instance of subtype</span>
<span class="sd">        SortedListWithKey.</span>

<span class="sd">        An optional *load* specifies the load-factor of the list. The default</span>
<span class="sd">        load factor of &#39;1000&#39; works well for lists from tens to tens of millions</span>
<span class="sd">        of elements.  Good practice is to use a value that is the cube root of</span>
<span class="sd">        the list size.  With billions of elements, the best load factor depends</span>
<span class="sd">        on your usage.  It&#39;s best to leave the load factor at the default until</span>
<span class="sd">        you start benchmarking.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=unused-argument</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="n">SortedList</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">SortedListWithKey</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;inherit SortedListWithKey for key argument&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all the elements from the list.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[:]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">[:]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[:]</span>

    <span class="n">_clear</span> <span class="o">=</span> <span class="n">clear</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the element *val* to the list.&quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                <span class="n">pos</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">insort</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_lists</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">val</span><span class="p">])</span>
            <span class="n">_maxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Splits sublists that are more than double the load level.</span>

<span class="sd">        Updates the index when the sublist length is less than double the load</span>
<span class="sd">        level. This requires incrementing the nodes in a traversal from the</span>
<span class="sd">        leaf node to the root. For an example traversal see self._loc.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twice</span><span class="p">:</span>
            <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
            <span class="n">_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span>

            <span class="n">_lists_pos</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="n">half</span> <span class="o">=</span> <span class="n">_lists_pos</span><span class="p">[</span><span class="n">_load</span><span class="p">:]</span>
            <span class="k">del</span> <span class="n">_lists_pos</span><span class="p">[</span><span class="n">_load</span><span class="p">:]</span>
            <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">_lists_pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">_lists</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">half</span><span class="p">)</span>
            <span class="n">_maxes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">half</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">del</span> <span class="n">_index</span><span class="p">[:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_index</span><span class="p">:</span>
                <span class="n">child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="n">pos</span>
                <span class="k">while</span> <span class="n">child</span><span class="p">:</span>
                    <span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="p">(</span><span class="n">child</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
                <span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the list by adding all elements from *iterable*.&quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
        <span class="n">values</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
                <span class="n">values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">_lists</span><span class="p">))</span>
                <span class="n">values</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_add</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span>
                <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                    <span class="n">_add</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="n">_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span>
        <span class="n">_lists</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">pos</span><span class="p">:(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">_load</span><span class="p">)]</span>
                      <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">_load</span><span class="p">))</span>
        <span class="n">_maxes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sublist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">_lists</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[:]</span>

    <span class="n">_update</span> <span class="o">=</span> <span class="n">update</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if and only if *val* is an element in the list.&quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">discard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the first occurrence of *val*.</span>

<span class="sd">        If *val* is not a member, does nothing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove first occurrence of *val*.</span>

<span class="sd">        Raises ValueError if *val* is not present.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete the item at the given (pos, idx).</span>

<span class="sd">        Combines lists that are less than half the load level.</span>

<span class="sd">        Updates the index when the sublist length is more than half the load</span>
<span class="sd">        level. This requires decrementing the nodes in a traversal from the leaf</span>
<span class="sd">        node to the root. For an example traversal see self._loc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
        <span class="n">_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>

        <span class="n">_lists_pos</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>

        <span class="k">del</span> <span class="n">_lists_pos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">len_lists_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists_pos</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">len_lists_pos</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half</span><span class="p">:</span>

            <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">_lists_pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">_index</span><span class="p">:</span>
                <span class="n">child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="n">pos</span>
                <span class="k">while</span> <span class="n">child</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="p">(</span><span class="n">child</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
                <span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">pos</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">prev</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">_lists</span><span class="p">[</span><span class="n">prev</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
            <span class="n">_maxes</span><span class="p">[</span><span class="n">prev</span><span class="p">]</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">prev</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">del</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_index</span><span class="p">[:]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">len_lists_pos</span><span class="p">:</span>

            <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">_lists_pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">del</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_index</span><span class="p">[:]</span>

    <span class="k">def</span> <span class="nf">_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert an index pair (alpha, beta) into a single index that corresponds to</span>
<span class="sd">        the position of the value in the sorted list.</span>

<span class="sd">        Most queries require the index be built. Details of the index are</span>
<span class="sd">        described in self._build_index.</span>

<span class="sd">        Indexing requires traversing the tree from a leaf node to the root. The</span>
<span class="sd">        parent of each node is easily computable at (pos - 1) // 2.</span>

<span class="sd">        Left-child nodes are always at odd indices and right-child nodes are</span>
<span class="sd">        always at even indices.</span>

<span class="sd">        When traversing up from a right-child node, increment the total by the</span>
<span class="sd">        left-child node.</span>

<span class="sd">        The final index is the sum from traversal and the index in the sublist.</span>

<span class="sd">        For example, using the index from self._build_index:</span>

<span class="sd">        _index = 14 5 9 3 2 4 5</span>
<span class="sd">        _offset = 3</span>

<span class="sd">        Tree:</span>

<span class="sd">                 14</span>
<span class="sd">              5      9</span>
<span class="sd">            3   2  4   5</span>

<span class="sd">        Converting index pair (2, 3) into a single index involves iterating like</span>
<span class="sd">        so:</span>

<span class="sd">        1. Starting at the leaf node: offset + alpha = 3 + 2 = 5. We identify</span>
<span class="sd">           the node as a left-child node. At such nodes, we simply traverse to</span>
<span class="sd">           the parent.</span>

<span class="sd">        2. At node 9, position 2, we recognize the node as a right-child node</span>
<span class="sd">           and accumulate the left-child in our total. Total is now 5 and we</span>
<span class="sd">           traverse to the parent at position 0.</span>

<span class="sd">        3. Iteration ends at the root.</span>

<span class="sd">        Computing the index is the sum of the total and beta: 5 + 3 = 8.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pos</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">idx</span>

        <span class="n">_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_index</span><span class="p">()</span>

        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Increment pos to point in the index to len(self._lists[pos]).</span>

        <span class="n">pos</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span>

        <span class="c1"># Iterate until reaching the root of the index tree at pos = 0.</span>

        <span class="k">while</span> <span class="n">pos</span><span class="p">:</span>

            <span class="c1"># Right-child nodes are at odd indices. At such indices</span>
            <span class="c1"># account the total below the left child node.</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="n">_index</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Advance pos to the parent node.</span>

            <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">total</span> <span class="o">+</span> <span class="n">idx</span>

    <span class="k">def</span> <span class="nf">_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert an index into a pair (alpha, beta) that can be used to access</span>
<span class="sd">        the corresponding _lists[alpha][beta] position.</span>

<span class="sd">        Most queries require the index be built. Details of the index are</span>
<span class="sd">        described in self._build_index.</span>

<span class="sd">        Indexing requires traversing the tree to a leaf node. Each node has</span>
<span class="sd">        two children which are easily computable. Given an index, pos, the</span>
<span class="sd">        left-child is at pos * 2 + 1 and the right-child is at pos * 2 + 2.</span>

<span class="sd">        When the index is less than the left-child, traversal moves to the</span>
<span class="sd">        left sub-tree. Otherwise, the index is decremented by the left-child</span>
<span class="sd">        and traversal moves to the right sub-tree.</span>

<span class="sd">        At a child node, the indexing pair is computed from the relative</span>
<span class="sd">        position of the child node as compared with the offset and the remaining</span>
<span class="sd">        index.</span>

<span class="sd">        For example, using the index from self._build_index:</span>

<span class="sd">        _index = 14 5 9 3 2 4 5</span>
<span class="sd">        _offset = 3</span>

<span class="sd">        Tree:</span>

<span class="sd">                 14</span>
<span class="sd">              5      9</span>
<span class="sd">            3   2  4   5</span>

<span class="sd">        Indexing position 8 involves iterating like so:</span>

<span class="sd">        1. Starting at the root, position 0, 8 is compared with the left-child</span>
<span class="sd">           node (5) which it is greater than. When greater the index is</span>
<span class="sd">           decremented and the position is updated to the right child node.</span>

<span class="sd">        2. At node 9 with index 3, we again compare the index to the left-child</span>
<span class="sd">           node with value 4. Because the index is the less than the left-child</span>
<span class="sd">           node, we simply traverse to the left.</span>

<span class="sd">        3. At node 4 with index 3, we recognize that we are at a leaf node and</span>
<span class="sd">           stop iterating.</span>

<span class="sd">        4. To compute the sublist index, we subtract the offset from the index</span>
<span class="sd">           of the leaf node: 5 - 3 = 2. To compute the index in the sublist, we</span>
<span class="sd">           simply use the index remaining from iteration. In this case, 3.</span>

<span class="sd">        The final index pair from our example is (2, 3) which corresponds to</span>
<span class="sd">        index 8 in the sorted list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">last_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="n">idx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">last_len</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">last_len</span> <span class="o">+</span> <span class="n">idx</span>

            <span class="n">idx</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

            <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index out of range&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index out of range&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span>

        <span class="n">_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_index</span><span class="p">()</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">child</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">len_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_index</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">child</span> <span class="o">&lt;</span> <span class="n">len_index</span><span class="p">:</span>
            <span class="n">index_child</span> <span class="o">=</span> <span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">index_child</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">child</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">-=</span> <span class="n">index_child</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">child</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">child</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build an index for indexing the sorted list.</span>

<span class="sd">        Indexes are represented as binary trees in a dense array notation</span>
<span class="sd">        similar to a binary heap.</span>

<span class="sd">        For example, given a _lists representation storing integers:</span>

<span class="sd">        [0]: 1 2 3</span>
<span class="sd">        [1]: 4 5</span>
<span class="sd">        [2]: 6 7 8 9</span>
<span class="sd">        [3]: 10 11 12 13 14</span>

<span class="sd">        The first transformation maps the sub-lists by their length. The</span>
<span class="sd">        first row of the index is the length of the sub-lists.</span>

<span class="sd">        [0]: 3 2 4 5</span>

<span class="sd">        Each row after that is the sum of consecutive pairs of the previous row:</span>

<span class="sd">        [1]: 5 9</span>
<span class="sd">        [2]: 14</span>

<span class="sd">        Finally, the index is built by concatenating these lists together:</span>

<span class="sd">        _index = 14 5 9 3 2 4 5</span>

<span class="sd">        An offset storing the start of the first row is also stored:</span>

<span class="sd">        _offset = 3</span>

<span class="sd">        When built, the index can be used for efficient indexing into the list.</span>
<span class="sd">        See the comment and notes on self._pos for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">row0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">row0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span>

        <span class="n">head</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">row0</span><span class="p">)</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
        <span class="n">row1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">starmap</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">row1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">row1</span> <span class="o">+</span> <span class="n">row0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span>

        <span class="n">size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">log_e</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">row1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">row1</span><span class="p">)))</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="p">[</span><span class="n">row0</span><span class="p">,</span> <span class="n">row1</span><span class="p">]</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">head</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
            <span class="n">row</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">starmap</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">)))</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

        <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">size</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove the element at *idx*. Supports slicing.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">stop</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">&lt;=</span> <span class="mi">8</span> <span class="o">*</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">):</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
                        <span class="n">values</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

            <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

            <span class="c1"># Delete items from greatest index to least so</span>
            <span class="c1"># that the indices remain valid throughout iteration.</span>

            <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

            <span class="n">_pos</span><span class="p">,</span> <span class="n">_delete</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span>

            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">pos</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">_pos</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="n">_delete</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="n">_delitem</span> <span class="o">=</span> <span class="fm">__delitem__</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the element at *idx*. Supports slicing.&quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">stop</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">,</span> <span class="p">[])</span>

                <span class="n">start_pos</span><span class="p">,</span> <span class="n">start_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">stop</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
                    <span class="n">stop_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">stop_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">stop_pos</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stop_pos</span><span class="p">,</span> <span class="n">stop_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">start_pos</span> <span class="o">==</span> <span class="n">stop_pos</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">_lists</span><span class="p">[</span><span class="n">start_pos</span><span class="p">][</span><span class="n">start_idx</span><span class="p">:</span><span class="n">stop_idx</span><span class="p">]</span>

                <span class="n">prefix</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">start_pos</span><span class="p">][</span><span class="n">start_idx</span><span class="p">:]</span>
                <span class="n">middle</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[(</span><span class="n">start_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="n">stop_pos</span><span class="p">]</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="n">middle</span><span class="p">,</span> <span class="n">prefix</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">stop_pos</span><span class="p">][:</span><span class="n">stop_idx</span><span class="p">]</span>

                <span class="k">return</span> <span class="n">result</span>

            <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">result</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">result</span>

            <span class="c1"># Return a list because a negative step could</span>
            <span class="c1"># reverse the order of the items and this could</span>
            <span class="c1"># be the desired behavior.</span>

            <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index out of range&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">return</span> <span class="n">_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>

            <span class="n">len_last</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="o">-</span><span class="n">len_last</span> <span class="o">&lt;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">len_last</span> <span class="o">+</span> <span class="n">idx</span><span class="p">]</span>

            <span class="n">pos</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>

    <span class="n">_getitem</span> <span class="o">=</span> <span class="fm">__getitem__</span>

    <span class="k">def</span> <span class="nf">_check_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>

        <span class="n">pos</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="n">_len</span>

        <span class="c1"># Check that the inserted value is not less than the</span>
        <span class="c1"># previous value.</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">idx_prev</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">pos_prev</span> <span class="o">=</span> <span class="n">pos</span>

            <span class="k">if</span> <span class="n">idx_prev</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">pos_prev</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">idx_prev</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos_prev</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos_prev</span><span class="p">][</span><span class="n">idx_prev</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in sort order at index </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">idx</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Check that the inserted value is not greater than</span>
        <span class="c1"># the previous value.</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">idx_next</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">pos_next</span> <span class="o">=</span> <span class="n">pos</span>

            <span class="k">if</span> <span class="n">idx_next</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos_next</span><span class="p">]):</span>
                <span class="n">pos_next</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">idx_next</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos_next</span><span class="p">][</span><span class="n">idx_next</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in sort order at index </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">idx</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replace item at position *index* with *value*.</span>

<span class="sd">        Supports slice notation. Raises :exc:`ValueError` if the sort order</span>
<span class="sd">        would be violated. When used with a slice and iterable, the</span>
<span class="sd">        :exc:`ValueError` is raised before the list is mutated if the sort</span>
<span class="sd">        order would be violated by the operation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
        <span class="n">_check_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_order</span>
        <span class="n">_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">_len</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

            <span class="c1"># Copy value to avoid aliasing issues with self and cases where an</span>
            <span class="c1"># iterator is given.</span>

            <span class="n">values</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">step</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;attempt to assign sequence of size </span><span class="si">%s</span><span class="s1">&#39;</span>
                        <span class="s1">&#39; to extended slice of size </span><span class="si">%s</span><span class="s1">&#39;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)))</span>

                <span class="c1"># Keep a log of values that are set so that we can</span>
                <span class="c1"># roll back changes if ordering is violated.</span>

                <span class="n">log</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">_append</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="n">append</span>

                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
                    <span class="n">pos</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">_pos</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                    <span class="n">_append</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">loc</span><span class="p">],</span> <span class="n">val</span><span class="p">))</span>
                    <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">loc</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Validate ordering of new values.</span>

                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">newval</span> <span class="ow">in</span> <span class="n">log</span><span class="p">:</span>
                        <span class="n">_check_order</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">newval</span><span class="p">)</span>

                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>

                    <span class="c1"># Roll back changes from log.</span>

                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">oldval</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">log</span><span class="p">:</span>
                        <span class="n">pos</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">_pos</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                        <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">loc</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldval</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                            <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldval</span>

                    <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">stop</span> <span class="o">==</span> <span class="n">_len</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
                    <span class="c1"># When calculating indices, stop may be less than start.</span>
                    <span class="c1"># For example: ...[5:3:1] results in slice(5, 3, 1) which</span>
                    <span class="c1"># is a valid but not useful stop index.</span>
                    <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span>

                <span class="k">if</span> <span class="n">values</span><span class="p">:</span>

                    <span class="c1"># Check that given values are ordered properly.</span>

                    <span class="n">alphas</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                    <span class="n">betas</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                    <span class="nb">next</span><span class="p">(</span><span class="n">betas</span><span class="p">)</span>
                    <span class="n">pairs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">alphas</span><span class="p">,</span> <span class="n">betas</span><span class="p">)</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;=</span> <span class="n">beta</span> <span class="k">for</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;given values not in sort order&#39;</span><span class="p">)</span>

                    <span class="c1"># Check ordering in context of sorted list.</span>

                    <span class="k">if</span> <span class="n">start</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> not in sort order at index </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="nb">repr</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">start</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">stop</span> <span class="o">!=</span> <span class="n">_len</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> not in sort order at index </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="nb">repr</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">stop</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

                <span class="c1"># Delete the existing values.</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_delitem</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

                <span class="c1"># Insert the new values.</span>

                <span class="n">_insert</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">insert</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                    <span class="n">_insert</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">_pos</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="n">_check_order</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">loc</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator over the Sequence.</span>

<span class="sd">        Iterating the Sequence while adding or deleting values may raise a</span>
<span class="sd">        `RuntimeError` or fail to iterate over all entries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator to traverse the Sequence in reverse.</span>

<span class="sd">        Iterating the Sequence while adding or deleting values may raise a</span>
<span class="sd">        `RuntimeError` or fail to iterate over all entries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">reversed</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">islice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator that slices `self` from `start` to `stop` index,</span>
<span class="sd">        inclusive and exclusive respectively.</span>

<span class="sd">        When `reverse` is `True`, values are yielded from the iterator in</span>
<span class="sd">        reverse order.</span>

<span class="sd">        Both `start` and `stop` default to `None` which is automatically</span>
<span class="sd">        inclusive of the beginning and end.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_len</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>

        <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">stop</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>

        <span class="n">_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>

        <span class="n">min_pos</span><span class="p">,</span> <span class="n">min_idx</span> <span class="o">=</span> <span class="n">_pos</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="o">==</span> <span class="n">_len</span><span class="p">:</span>
            <span class="n">max_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_pos</span><span class="p">,</span> <span class="n">max_idx</span> <span class="o">=</span> <span class="n">_pos</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_islice</span><span class="p">(</span><span class="n">min_pos</span><span class="p">,</span> <span class="n">min_idx</span><span class="p">,</span> <span class="n">max_pos</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_islice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_pos</span><span class="p">,</span> <span class="n">min_idx</span><span class="p">,</span> <span class="n">max_pos</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">,</span> <span class="n">reverse</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator that slices `self` using two index pairs,</span>
<span class="sd">        `(min_pos, min_idx)` and `(max_pos, max_idx)`; the first inclusive</span>
<span class="sd">        and the latter exclusive. See `_pos` for details on how an index</span>
<span class="sd">        is converted to an index pair.</span>

<span class="sd">        When `reverse` is `True`, values are yielded from the iterator in</span>
<span class="sd">        reverse order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>

        <span class="k">if</span> <span class="n">min_pos</span> <span class="o">&gt;</span> <span class="n">max_pos</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>
        <span class="k">elif</span> <span class="n">min_pos</span> <span class="o">==</span> <span class="n">max_pos</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">][</span><span class="n">min_idx</span><span class="p">:</span><span class="n">max_idx</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">min_pos</span> <span class="o">==</span> <span class="n">max_pos</span> <span class="ow">and</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">][</span><span class="n">min_idx</span><span class="p">:</span><span class="n">max_idx</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">min_pos</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">max_pos</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">chain</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">][</span><span class="n">min_idx</span><span class="p">:],</span> <span class="n">_lists</span><span class="p">[</span><span class="n">max_pos</span><span class="p">][:</span><span class="n">max_idx</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">min_pos</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">max_pos</span> <span class="ow">and</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">chain</span><span class="p">(</span>
                <span class="nb">reversed</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">max_pos</span><span class="p">][:</span><span class="n">max_idx</span><span class="p">]),</span>
                <span class="nb">reversed</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">][</span><span class="n">min_idx</span><span class="p">:]),</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">chain</span><span class="p">(</span>
                <span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">][</span><span class="n">min_idx</span><span class="p">:],</span>
                <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">_lists</span><span class="p">[(</span><span class="n">min_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="n">max_pos</span><span class="p">]),</span>
                <span class="n">_lists</span><span class="p">[</span><span class="n">max_pos</span><span class="p">][:</span><span class="n">max_idx</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">reversed</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">_lists</span><span class="p">[(</span><span class="n">min_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="n">max_pos</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">chain</span><span class="p">(</span>
                <span class="nb">reversed</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">max_pos</span><span class="p">][:</span><span class="n">max_idx</span><span class="p">]),</span>
                <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">temp</span><span class="p">),</span>
                <span class="nb">reversed</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">][</span><span class="n">min_idx</span><span class="p">:]),</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">irange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minimum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maximum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
               <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an iterator of values between `minimum` and `maximum`.</span>

<span class="sd">        `inclusive` is a pair of booleans that indicates whether the minimum</span>
<span class="sd">        and maximum ought to be included in the range, respectively. The</span>
<span class="sd">        default is (True, True) such that the range is inclusive of both</span>
<span class="sd">        minimum and maximum.</span>

<span class="sd">        Both `minimum` and `maximum` default to `None` which is automatically</span>
<span class="sd">        inclusive of the start and end of the list, respectively.</span>

<span class="sd">        When `reverse` is `True` the values are yielded from the iterator in</span>
<span class="sd">        reverse order; `reverse` defaults to `False`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>

        <span class="c1"># Calculate the minimum (pos, idx) pair. By default this location</span>
        <span class="c1"># will be inclusive in our calculation.</span>

        <span class="k">if</span> <span class="n">minimum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_pos</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">min_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inclusive</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">min_pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">minimum</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">min_pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>

                <span class="n">min_idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">],</span> <span class="n">minimum</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_pos</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">minimum</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">min_pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>

                <span class="n">min_idx</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">],</span> <span class="n">minimum</span><span class="p">)</span>

        <span class="c1"># Calculate the maximum (pos, idx) pair. By default this location</span>
        <span class="c1"># will be exclusive in our calculation.</span>

        <span class="k">if</span> <span class="n">maximum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">max_pos</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inclusive</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">max_pos</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">maximum</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">max_pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                    <span class="n">max_pos</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">max_pos</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">max_idx</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">max_pos</span><span class="p">],</span> <span class="n">maximum</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">maximum</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">max_pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                    <span class="n">max_pos</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">max_pos</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">max_idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">max_pos</span><span class="p">],</span> <span class="n">maximum</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_islice</span><span class="p">(</span><span class="n">min_pos</span><span class="p">,</span> <span class="n">min_idx</span><span class="p">,</span> <span class="n">max_pos</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of elements in the list.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

    <span class="k">def</span> <span class="nf">bisect_left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to the *bisect* module in the standard library, this returns an</span>
<span class="sd">        appropriate index to insert *val*. If *val* is already present, the</span>
<span class="sd">        insertion point will be before (to the left of) any existing entries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bisect_right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as *bisect_left*, but if *val* is already present, the insertion</span>
<span class="sd">        point will be after (to the right of) any existing entries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="n">bisect</span> <span class="o">=</span> <span class="n">bisect_right</span>
    <span class="n">_bisect_right</span> <span class="o">=</span> <span class="n">bisect_right</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of occurrences of *val* in the list.&quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">pos_left</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos_left</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">idx_left</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos_left</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>
        <span class="n">pos_right</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos_right</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">(</span><span class="n">pos_left</span><span class="p">,</span> <span class="n">idx_left</span><span class="p">)</span>

        <span class="n">idx_right</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos_right</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos_left</span> <span class="o">==</span> <span class="n">pos_right</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">idx_right</span> <span class="o">-</span> <span class="n">idx_left</span>

        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">(</span><span class="n">pos_right</span><span class="p">,</span> <span class="n">idx_right</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">(</span><span class="n">pos_left</span><span class="p">,</span> <span class="n">idx_left</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a shallow copy of the sorted list.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">load</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span>

    <span class="n">__copy__</span> <span class="o">=</span> <span class="n">copy</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append the element *val* to the list. Raises a ValueError if the *val*</span>
<span class="sd">        would violate the sort order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="n">_maxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="n">_lists</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">val</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in sort order at index </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extend the list by appending all elements from the *values*. Raises a</span>
<span class="sd">        ValueError if the sort order would be violated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
        <span class="n">_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">values</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
               <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;given sequence not in sort order&#39;</span><span class="p">)</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in sort order at index </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half</span><span class="p">:</span>
                <span class="n">_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">values</span><span class="p">[:</span><span class="n">_load</span><span class="p">])</span>
                <span class="n">_maxes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">_load</span>

        <span class="n">len_lists</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">_load</span><span class="p">):</span>
            <span class="n">_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">idx</span><span class="p">:(</span><span class="n">idx</span> <span class="o">+</span> <span class="n">_load</span><span class="p">)])</span>
            <span class="n">_maxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>

        <span class="k">if</span> <span class="n">len_lists</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">):</span>
            <span class="n">len_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">len_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">len_values</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                <span class="n">child</span> <span class="o">=</span> <span class="n">len_index</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">child</span><span class="p">:</span>
                    <span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">+=</span> <span class="n">len_values</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="p">(</span><span class="n">child</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
                <span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">len_values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">_index</span><span class="p">[:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert the element *val* into the list at *idx*. Raises a ValueError if</span>
<span class="sd">        the *val* at *idx* would violate the sort order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="n">_len</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="n">_len</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">_len</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="c1"># The idx must be zero by the inequalities above.</span>
            <span class="n">_maxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="n">_lists</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">val</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in sort order at index </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">return</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">_len</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in sort order at index </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">_len</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">return</span>

        <span class="n">pos</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">idx_before</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">idx_before</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pos_before</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">idx_before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos_before</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos_before</span> <span class="o">=</span> <span class="n">pos</span>

        <span class="n">before</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos_before</span><span class="p">][</span><span class="n">idx_before</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">before</span> <span class="o">&lt;=</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]:</span>
            <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in sort order at index </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">idx</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove and return item at *idx* (default last).  Raises IndexError if</span>
<span class="sd">        list is empty or index is out of range.  Negative indices are supported,</span>
<span class="sd">        as for slice indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;pop index out of range&#39;</span><span class="p">)</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">val</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">loc</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">val</span>

        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">val</span>

        <span class="n">len_last</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="o">-</span><span class="n">len_last</span> <span class="o">&lt;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">len_last</span> <span class="o">+</span> <span class="n">idx</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">loc</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">val</span>

        <span class="n">pos</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the smallest *k* such that L[k] == val and i &lt;= k &lt; j`.  Raises</span>
<span class="sd">        ValueError if *val* is not present.  *stop* defaults to the end of the</span>
<span class="sd">        list. *start* defaults to the beginning. Negative indices are supported,</span>
<span class="sd">        as for slice indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=arguments-differ</span>
        <span class="n">_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_len</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">_len</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">_len</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">+=</span> <span class="n">_len</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="n">_len</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">_len</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>

        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
        <span class="n">pos_left</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos_left</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">idx_left</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos_left</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos_left</span><span class="p">][</span><span class="n">idx_left</span><span class="p">]</span> <span class="o">!=</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>

        <span class="n">stop</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">(</span><span class="n">pos_left</span><span class="p">,</span> <span class="n">idx_left</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">left</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">stop</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">left</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bisect_right</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">start</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">that</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new sorted list containing all the elements in *self* and</span>
<span class="sd">        *that*. Elements in *that* do not need to be properly ordered with</span>
<span class="sd">        respect to *self*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">that</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">load</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">that</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update *self* to include all values in *that*. Elements in *that* do not</span>
<span class="sd">        need to be properly ordered with respect to *self*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">that</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">that</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new sorted list containing *that* shallow copies of each item</span>
<span class="sd">        in SortedList.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">,</span> <span class="p">[])</span> <span class="o">*</span> <span class="n">that</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">load</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">that</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Increase the length of the list by appending *that* shallow copies of</span>
<span class="sd">        each item.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">,</span> <span class="p">[])</span> <span class="o">*</span> <span class="n">that</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_make_cmp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_op</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="s2">&quot;Make comparator method.&quot;</span>
        <span class="k">def</span> <span class="nf">comparer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">that</span><span class="p">):</span>
            <span class="s2">&quot;Compare method for sorted list and sequence.&quot;</span>
            <span class="c1"># pylint: disable=protected-access</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">that</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

            <span class="n">self_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>
            <span class="n">len_that</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">that</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">self_len</span> <span class="o">!=</span> <span class="n">len_that</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">seq_op</span> <span class="ow">is</span> <span class="n">op</span><span class="o">.</span><span class="n">eq</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">seq_op</span> <span class="ow">is</span> <span class="n">op</span><span class="o">.</span><span class="n">ne</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>

            <span class="k">for</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">that</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">alpha</span> <span class="o">!=</span> <span class="n">beta</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">seq_op</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">seq_op</span><span class="p">(</span><span class="n">self_len</span><span class="p">,</span> <span class="n">len_that</span><span class="p">)</span>

        <span class="n">comparer</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s1">&#39;__</span><span class="si">{0}</span><span class="s1">__&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">seq_op</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">doc_str</span> <span class="o">=</span> <span class="s1">&#39;Return `True` if and only if Sequence is </span><span class="si">{0}</span><span class="s1"> `that`.&#39;</span>
        <span class="n">comparer</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doc_str</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">comparer</span>

    <span class="fm">__eq__</span> <span class="o">=</span> <span class="n">_make_cmp</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span> <span class="s1">&#39;equal to&#39;</span><span class="p">)</span>
    <span class="fm">__ne__</span> <span class="o">=</span> <span class="n">_make_cmp</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">ne</span><span class="p">,</span> <span class="s1">&#39;not equal to&#39;</span><span class="p">)</span>
    <span class="fm">__lt__</span> <span class="o">=</span> <span class="n">_make_cmp</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">lt</span><span class="p">,</span> <span class="s1">&#39;less than&#39;</span><span class="p">)</span>
    <span class="fm">__gt__</span> <span class="o">=</span> <span class="n">_make_cmp</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span> <span class="s1">&#39;greater than&#39;</span><span class="p">)</span>
    <span class="fm">__le__</span> <span class="o">=</span> <span class="n">_make_cmp</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">le</span><span class="p">,</span> <span class="s1">&#39;less than or equal to&#39;</span><span class="p">)</span>
    <span class="fm">__ge__</span> <span class="o">=</span> <span class="n">_make_cmp</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">ge</span><span class="p">,</span> <span class="s1">&#39;greater than or equal to&#39;</span><span class="p">)</span>

    <span class="nd">@recursive_repr</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return string representation of sequence.&quot;&quot;&quot;</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">(</span><span class="si">{1}</span><span class="s1">, load=</span><span class="si">{2}</span><span class="s1">)&#39;</span>
        <span class="k">return</span> <span class="n">temp</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="nb">repr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span>
            <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Check load parameters.</span>

            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">&gt;=</span> <span class="mi">4</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twice</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Check empty sorted list case.</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span> <span class="o">==</span> <span class="p">[]</span>
                <span class="k">return</span>

            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

            <span class="c1"># Check all sublists are sorted.</span>

            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">sublist</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">sublist</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
                       <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)))</span>

            <span class="c1"># Check beginning/end of sublists are sorted.</span>

            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)):</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Check length of _maxes and _lists match.</span>

            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>

            <span class="c1"># Check _maxes is a map of _lists.</span>

            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">)))</span>

            <span class="c1"># Check load level is less than _twice.</span>

            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twice</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>

            <span class="c1"># Check load level is greater than _half for all</span>
            <span class="c1"># but the last sublist.</span>

            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half</span>
                       <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

            <span class="c1"># Check length.</span>

            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>

            <span class="c1"># Check index.</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">def</span> <span class="nf">test_offset_pos</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
                    <span class="s2">&quot;Test positional indexing offset.&quot;</span>
                    <span class="n">from_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="n">pos</span><span class="p">]</span>
                    <span class="k">return</span> <span class="n">from_index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>

                <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">test_offset_pos</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)))</span>

                <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">):</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">child</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">):</span>
                        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="n">child</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">):</span>
                        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">child_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">child</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">child_sum</span>

        <span class="k">except</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">sys</span>
            <span class="kn">import</span> <span class="nn">traceback</span>

            <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twice</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len_index&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len_maxes&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;maxes&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len_lists&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;lists&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>

            <span class="k">raise</span>

<span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="s2">&quot;Identity function.&quot;</span>
    <span class="k">return</span> <span class="n">value</span>

<span class="k">class</span> <span class="nc">SortedListWithKey</span><span class="p">(</span><span class="n">SortedList</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SortedListWithKey provides most of the same methods as a list but keeps</span>
<span class="sd">    the items in sorted order.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">identity</span><span class="p">,</span> <span class="n">load</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;SortedListWithKey provides most of the same methods as list but keeps the</span>
<span class="sd">        items in sorted order.</span>

<span class="sd">        An optional *iterable* provides an initial series of items to populate</span>
<span class="sd">        the SortedListWithKey.</span>

<span class="sd">        An optional *key* argument defines a callable that, like the `key`</span>
<span class="sd">        argument to Python&#39;s `sorted` function, extracts a comparison key from</span>
<span class="sd">        each element. The default is the identity function.</span>

<span class="sd">        An optional *load* specifies the load-factor of the list. The default</span>
<span class="sd">        load factor of &#39;1000&#39; works well for lists from tens to tens of millions</span>
<span class="sd">        of elements.  Good practice is to use a value that is the cube root of</span>
<span class="sd">        the list size.  With billions of elements, the best load factor depends</span>
<span class="sd">        on your usage.  It&#39;s best to leave the load factor at the default until</span>
<span class="sd">        you start benchmarking.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=super-init-not-called</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">=</span> <span class="n">load</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_twice</span> <span class="o">=</span> <span class="n">load</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_half</span> <span class="o">=</span> <span class="n">load</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">iterable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">iterable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">identity</span><span class="p">,</span> <span class="n">load</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all the elements from the list.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[:]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">[:]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">[:]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[:]</span>

    <span class="n">_clear</span> <span class="o">=</span> <span class="n">clear</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the element *val* to the list.&quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                <span class="n">pos</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>
                <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_lists</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">val</span><span class="p">])</span>
            <span class="n">_keys</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">key</span><span class="p">])</span>
            <span class="n">_maxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Splits sublists that are more than double the load level.</span>

<span class="sd">        Updates the index when the sublist length is less than double the load</span>
<span class="sd">        level. This requires incrementing the nodes in a traversal from the</span>
<span class="sd">        leaf node to the root. For an example traversal see self._loc.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twice</span><span class="p">:</span>
            <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
            <span class="n">_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span>

            <span class="n">_lists_pos</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="n">_keys_pos</span> <span class="o">=</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="n">half</span> <span class="o">=</span> <span class="n">_lists_pos</span><span class="p">[</span><span class="n">_load</span><span class="p">:]</span>
            <span class="n">half_keys</span> <span class="o">=</span> <span class="n">_keys_pos</span><span class="p">[</span><span class="n">_load</span><span class="p">:]</span>
            <span class="k">del</span> <span class="n">_lists_pos</span><span class="p">[</span><span class="n">_load</span><span class="p">:]</span>
            <span class="k">del</span> <span class="n">_keys_pos</span><span class="p">[</span><span class="n">_load</span><span class="p">:]</span>
            <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">_keys_pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">_lists</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">half</span><span class="p">)</span>
            <span class="n">_keys</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">half_keys</span><span class="p">)</span>
            <span class="n">_maxes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">half_keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">del</span> <span class="n">_index</span><span class="p">[:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_index</span><span class="p">:</span>
                <span class="n">child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="n">pos</span>
                <span class="k">while</span> <span class="n">child</span><span class="p">:</span>
                    <span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="p">(</span><span class="n">child</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
                <span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the list by adding all elements from *iterable*.&quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
        <span class="n">values</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
                <span class="n">values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">_lists</span><span class="p">))</span>
                <span class="n">values</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_add</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span>
                <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                    <span class="n">_add</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="n">_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span>
        <span class="n">_lists</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">pos</span><span class="p">:(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">_load</span><span class="p">)]</span>
                      <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">_load</span><span class="p">))</span>
        <span class="n">_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">,</span> <span class="n">_list</span><span class="p">))</span> <span class="k">for</span> <span class="n">_list</span> <span class="ow">in</span> <span class="n">_lists</span><span class="p">)</span>
        <span class="n">_maxes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sublist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">_keys</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[:]</span>

    <span class="n">_update</span> <span class="o">=</span> <span class="n">update</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if and only if *val* is an element in the list.&quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>

        <span class="n">len_keys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">)</span>
        <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">len_sublist</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">len_keys</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">discard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the first occurrence of *val*.</span>

<span class="sd">        If *val* is not a member, does nothing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">len_keys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">)</span>
        <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">len_sublist</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">len_keys</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove first occurrence of *val*.</span>

<span class="sd">        Raises ValueError if *val* is not present.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>

        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">len_keys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">)</span>
        <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">len_sublist</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">len_keys</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>
                <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete the item at the given (pos, idx).</span>

<span class="sd">        Combines lists that are less than half the load level.</span>

<span class="sd">        Updates the index when the sublist length is more than half the load</span>
<span class="sd">        level. This requires decrementing the nodes in a traversal from the leaf</span>
<span class="sd">        node to the root. For an example traversal see self._loc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
        <span class="n">_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>
        <span class="n">keys_pos</span> <span class="o">=</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
        <span class="n">lists_pos</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>

        <span class="k">del</span> <span class="n">keys_pos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">lists_pos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">len_keys_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys_pos</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">len_keys_pos</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half</span><span class="p">:</span>

            <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">keys_pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">_index</span><span class="p">:</span>
                <span class="n">child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="n">pos</span>
                <span class="k">while</span> <span class="n">child</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="p">(</span><span class="n">child</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
                <span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">pos</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">prev</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">_keys</span><span class="p">[</span><span class="n">prev</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
            <span class="n">_lists</span><span class="p">[</span><span class="n">prev</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
            <span class="n">_maxes</span><span class="p">[</span><span class="n">prev</span><span class="p">]</span> <span class="o">=</span> <span class="n">_keys</span><span class="p">[</span><span class="n">prev</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">del</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_index</span><span class="p">[:]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">len_keys_pos</span><span class="p">:</span>

            <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">keys_pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">del</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_index</span><span class="p">[:]</span>

    <span class="k">def</span> <span class="nf">_check_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="c1"># pylint: disable=arguments-differ</span>
        <span class="n">_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>

        <span class="n">pos</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="n">_len</span>

        <span class="c1"># Check that the inserted value is not less than the</span>
        <span class="c1"># previous value.</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">idx_prev</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">pos_prev</span> <span class="o">=</span> <span class="n">pos</span>

            <span class="k">if</span> <span class="n">idx_prev</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">pos_prev</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">idx_prev</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos_prev</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos_prev</span><span class="p">][</span><span class="n">idx_prev</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in sort order at index </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">idx</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Check that the inserted value is not greater than</span>
        <span class="c1"># the previous value.</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">idx_next</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">pos_next</span> <span class="o">=</span> <span class="n">pos</span>

            <span class="k">if</span> <span class="n">idx_next</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos_next</span><span class="p">]):</span>
                <span class="n">pos_next</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">idx_next</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos_next</span><span class="p">][</span><span class="n">idx_next</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in sort order at index </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">idx</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace the item at position *index* with *value*.</span>

<span class="sd">        Supports slice notation. Raises a :exc:`ValueError` if the sort order</span>
<span class="sd">        would be violated. When used with a slice and iterable, the</span>
<span class="sd">        :exc:`ValueError` is raised before the list is mutated if the sort order</span>
<span class="sd">        would be violated by the operation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
        <span class="n">_check_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_order</span>
        <span class="n">_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">step</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;attempt to assign sequence of size </span><span class="si">{0}</span><span class="s1">&#39;</span>
                        <span class="s1">&#39; to extended slice of size </span><span class="si">{1}</span><span class="s1">&#39;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)))</span>

                <span class="c1"># Keep a log of values that are set so that we can</span>
                <span class="c1"># roll back changes if ordering is violated.</span>

                <span class="n">log</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">_append</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="n">append</span>

                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                    <span class="n">pos</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">_pos</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                    <span class="n">_append</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">loc</span><span class="p">],</span> <span class="n">key</span><span class="p">,</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">loc</span><span class="p">],</span> <span class="n">val</span><span class="p">))</span>
                    <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">loc</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
                    <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">loc</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Validate ordering of new values.</span>

                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">oldkey</span><span class="p">,</span> <span class="n">newkey</span><span class="p">,</span> <span class="n">oldval</span><span class="p">,</span> <span class="n">newval</span> <span class="ow">in</span> <span class="n">log</span><span class="p">:</span>
                        <span class="n">_check_order</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">newkey</span><span class="p">,</span> <span class="n">newval</span><span class="p">)</span>

                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>

                    <span class="c1"># Roll back changes from log.</span>

                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">oldkey</span><span class="p">,</span> <span class="n">newkey</span><span class="p">,</span> <span class="n">oldval</span><span class="p">,</span> <span class="n">newval</span> <span class="ow">in</span> <span class="n">log</span><span class="p">:</span>
                        <span class="n">pos</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">_pos</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                        <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">loc</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldkey</span>
                        <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">loc</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldval</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                            <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldkey</span>

                    <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">stop</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                <span class="c1"># Test ordering using indexing. If the given value</span>
                <span class="c1"># isn&#39;t a Sequence, convert it to a tuple.</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="c1"># pylint: disable=redefined-variable-type</span>

                <span class="c1"># Check that the given values are ordered properly.</span>

                <span class="n">keys</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
                <span class="n">iterator</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">))</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">keys</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;given sequence not in sort order&#39;</span><span class="p">)</span>

                <span class="c1"># Check ordering in context of sorted list.</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">start</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="c1"># Nothing to check on the lhs.</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pos</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">_pos</span><span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">loc</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in sort order at index </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">start</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">stop</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="c1"># Nothing to check on the rhs.</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># &quot;stop&quot; is exclusive so we don&#39;t need</span>
                    <span class="c1"># to add one for the index.</span>
                    <span class="n">pos</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">_pos</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">loc</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in sort order at index </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">stop</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="c1"># Delete the existing values.</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_delitem</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

                <span class="c1"># Insert the new values.</span>

                <span class="n">_insert</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">insert</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="n">_insert</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">_pos</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">_check_order</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">loc</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">loc</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">irange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minimum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maximum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
               <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an iterator of values between `minimum` and `maximum`.</span>

<span class="sd">        `inclusive` is a pair of booleans that indicates whether the minimum</span>
<span class="sd">        and maximum ought to be included in the range, respectively. The</span>
<span class="sd">        default is (True, True) such that the range is inclusive of both</span>
<span class="sd">        minimum and maximum.</span>

<span class="sd">        Both `minimum` and `maximum` default to `None` which is automatically</span>
<span class="sd">        inclusive of the start and end of the list, respectively.</span>

<span class="sd">        When `reverse` is `True` the values are yielded from the iterator in</span>
<span class="sd">        reverse order; `reverse` defaults to `False`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">minimum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">minimum</span><span class="p">)</span> <span class="k">if</span> <span class="n">minimum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">maximum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">maximum</span><span class="p">)</span> <span class="k">if</span> <span class="n">maximum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_irange_key</span><span class="p">(</span>
            <span class="n">min_key</span><span class="o">=</span><span class="n">minimum</span><span class="p">,</span> <span class="n">max_key</span><span class="o">=</span><span class="n">maximum</span><span class="p">,</span>
            <span class="n">inclusive</span><span class="o">=</span><span class="n">inclusive</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">irange_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
                   <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an iterator of values between `min_key` and `max_key`.</span>

<span class="sd">        `inclusive` is a pair of booleans that indicates whether the min_key</span>
<span class="sd">        and max_key ought to be included in the range, respectively. The</span>
<span class="sd">        default is (True, True) such that the range is inclusive of both</span>
<span class="sd">        `min_key` and `max_key`.</span>

<span class="sd">        Both `min_key` and `max_key` default to `None` which is automatically</span>
<span class="sd">        inclusive of the start and end of the list, respectively.</span>

<span class="sd">        When `reverse` is `True` the values are yielded from the iterator in</span>
<span class="sd">        reverse order; `reverse` defaults to `False`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>

        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>

        <span class="c1"># Calculate the minimum (pos, idx) pair. By default this location</span>
        <span class="c1"># will be inclusive in our calculation.</span>

        <span class="k">if</span> <span class="n">min_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_pos</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">min_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inclusive</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">min_pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">min_key</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">min_pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>

                <span class="n">min_idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">min_pos</span><span class="p">],</span> <span class="n">min_key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_pos</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">min_key</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">min_pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>

                <span class="n">min_idx</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">min_pos</span><span class="p">],</span> <span class="n">min_key</span><span class="p">)</span>

        <span class="c1"># Calculate the maximum (pos, idx) pair. By default this location</span>
        <span class="c1"># will be exclusive in our calculation.</span>

        <span class="k">if</span> <span class="n">max_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">max_pos</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inclusive</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">max_pos</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">max_key</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">max_pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                    <span class="n">max_pos</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">max_pos</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">max_idx</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">max_pos</span><span class="p">],</span> <span class="n">max_key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">max_key</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">max_pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                    <span class="n">max_pos</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">max_pos</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">max_idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">max_pos</span><span class="p">],</span> <span class="n">max_key</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_islice</span><span class="p">(</span><span class="n">min_pos</span><span class="p">,</span> <span class="n">min_idx</span><span class="p">,</span> <span class="n">max_pos</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span>

    <span class="n">_irange_key</span> <span class="o">=</span> <span class="n">irange_key</span>

    <span class="k">def</span> <span class="nf">bisect_left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to the *bisect* module in the standard library, this returns an</span>
<span class="sd">        appropriate index to insert *val*. If *val* is already present, the</span>
<span class="sd">        insertion point will be before (to the left of) any existing entries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bisect_key_left</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">bisect_right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as *bisect_left*, but if *val* is already present, the insertion</span>
<span class="sd">        point will be after (to the right of) any existing entries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bisect_key_right</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

    <span class="n">bisect</span> <span class="o">=</span> <span class="n">bisect_right</span>

    <span class="k">def</span> <span class="nf">bisect_key_left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to the *bisect* module in the standard library, this returns an</span>
<span class="sd">        appropriate index to insert a value with a given *key*. If values with</span>
<span class="sd">        *key* are already present, the insertion point will be before (to the</span>
<span class="sd">        left of) any existing entries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="n">_bisect_key_left</span> <span class="o">=</span> <span class="n">bisect_key_left</span>

    <span class="k">def</span> <span class="nf">bisect_key_right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as *bisect_key_left*, but if *key* is already present, the insertion</span>
<span class="sd">        point will be after (to the right of) any existing entries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="n">bisect_key</span> <span class="o">=</span> <span class="n">bisect_key_right</span>
    <span class="n">_bisect_key_right</span> <span class="o">=</span> <span class="n">bisect_key_right</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of occurrences of *val* in the list.&quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">len_keys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">)</span>
        <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">total</span>
            <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">len_sublist</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">len_keys</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">total</span>
                <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a shallow copy of the sorted list.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">,</span> <span class="n">load</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span>

    <span class="n">__copy__</span> <span class="o">=</span> <span class="n">copy</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append the element *val* to the list. Raises a ValueError if the *val*</span>
<span class="sd">        would violate the sort order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="n">_maxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">_keys</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">key</span><span class="p">])</span>
            <span class="n">_lists</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">val</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in sort order at index </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extend the list by appending all elements from the *values*. Raises a</span>
<span class="sd">        ValueError if the sort order would be violated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
        <span class="n">_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">keys</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
               <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;given sequence not in sort order&#39;</span><span class="p">)</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">_keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in sort order at index </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half</span><span class="p">:</span>
                <span class="n">_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">values</span><span class="p">[:</span><span class="n">_load</span><span class="p">])</span>
                <span class="n">_keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">keys</span><span class="p">[:</span><span class="n">_load</span><span class="p">])</span>
                <span class="n">_maxes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">_load</span>

        <span class="n">len_keys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span> <span class="n">_load</span><span class="p">):</span>
            <span class="n">_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">idx</span><span class="p">:(</span><span class="n">idx</span> <span class="o">+</span> <span class="n">_load</span><span class="p">)])</span>
            <span class="n">_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="n">idx</span><span class="p">:(</span><span class="n">idx</span> <span class="o">+</span> <span class="n">_load</span><span class="p">)])</span>
            <span class="n">_maxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>

        <span class="k">if</span> <span class="n">len_keys</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">):</span>
            <span class="n">len_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">len_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">len_values</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                <span class="n">child</span> <span class="o">=</span> <span class="n">len_index</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">child</span><span class="p">:</span>
                    <span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">+=</span> <span class="n">len_values</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="p">(</span><span class="n">child</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
                <span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">len_values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">_index</span><span class="p">[:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert the element *val* into the list at *idx*. Raises a ValueError if</span>
<span class="sd">        the *val* at *idx* would violate the sort order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="n">_len</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="n">_len</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">_len</span>

        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">_lists</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">val</span><span class="p">])</span>
            <span class="n">_keys</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">key</span><span class="p">])</span>
            <span class="n">_maxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in sort order at index </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="n">_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">_len</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in sort order at index </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">_len</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="n">pos</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">idx_before</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">idx_before</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pos_before</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">idx_before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos_before</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos_before</span> <span class="o">=</span> <span class="n">pos</span>

        <span class="n">before</span> <span class="o">=</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos_before</span><span class="p">][</span><span class="n">idx_before</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">before</span> <span class="o">&lt;=</span> <span class="n">key</span> <span class="o">&lt;=</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> not in sort order at index </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">idx</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the smallest *k* such that L[k] == val and i &lt;= k &lt; j`.  Raises</span>
<span class="sd">        ValueError if *val* is not present.  *stop* defaults to the end of the</span>
<span class="sd">        list. *start* defaults to the beginning. Negative indices are supported,</span>
<span class="sd">        as for slice indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_len</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">_len</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">_len</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">+=</span> <span class="n">_len</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="n">_len</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">_len</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>

        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>

        <span class="n">stop</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">len_keys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">)</span>
        <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">loc</span> <span class="o">&lt;=</span> <span class="n">stop</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">loc</span>
                <span class="k">elif</span> <span class="n">loc</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">len_sublist</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">len_keys</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>
                <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">that</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new sorted list containing all the elements in *self* and</span>
<span class="sd">        *that*. Elements in *that* do not need to be properly ordered with</span>
<span class="sd">        respect to *self*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">that</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">,</span> <span class="n">load</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">that</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new sorted list containing *that* shallow copies of each item</span>
<span class="sd">        in SortedListWithKey.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">,</span> <span class="p">[])</span> <span class="o">*</span> <span class="n">that</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">,</span> <span class="n">load</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">that</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Increase the length of the list by appending *that* shallow copies of</span>
<span class="sd">        each item.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">,</span> <span class="p">[])</span> <span class="o">*</span> <span class="n">that</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@recursive_repr</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return string representation of sequence.&quot;&quot;&quot;</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">(</span><span class="si">{1}</span><span class="s1">, key=</span><span class="si">{2}</span><span class="s1">, load=</span><span class="si">{3}</span><span class="s1">)&#39;</span>
        <span class="k">return</span> <span class="n">temp</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="nb">repr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span>
            <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">),</span>
            <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Check load parameters.</span>

            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">&gt;=</span> <span class="mi">4</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twice</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Check empty sorted list case.</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span> <span class="o">==</span> <span class="p">[]</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span> <span class="o">==</span> <span class="p">[]</span>
                <span class="k">return</span>

            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

            <span class="c1"># Check all sublists are sorted.</span>

            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">sublist</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">sublist</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
                       <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)))</span>

            <span class="c1"># Check beginning/end of sublists are sorted.</span>

            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">)):</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Check length of _maxes and _lists match.</span>

            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">)</span>

            <span class="c1"># Check _keys matches _key mapped to _lists.</span>

            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">key_list</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">val_list</span><span class="p">,</span> <span class="n">key_list</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">))</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="n">key</span> <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span>
                       <span class="nb">zip</span><span class="p">((</span><span class="n">_val</span> <span class="k">for</span> <span class="n">_val_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span> <span class="k">for</span> <span class="n">_val</span> <span class="ow">in</span> <span class="n">_val_list</span><span class="p">),</span>
                           <span class="p">(</span><span class="n">_key</span> <span class="k">for</span> <span class="n">_key_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span> <span class="k">for</span> <span class="n">_key</span> <span class="ow">in</span> <span class="n">_key_list</span><span class="p">)))</span>

            <span class="c1"># Check _maxes is a map of _keys.</span>

            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">)))</span>

            <span class="c1"># Check load level is less than _twice.</span>

            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twice</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>

            <span class="c1"># Check load level is greater than _half for all</span>
            <span class="c1"># but the last sublist.</span>

            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half</span>
                       <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

            <span class="c1"># Check length.</span>

            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>

            <span class="c1"># Check index.</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">def</span> <span class="nf">test_offset_pos</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
                    <span class="s2">&quot;Test positional indexing offset.&quot;</span>
                    <span class="n">from_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="n">pos</span><span class="p">]</span>
                    <span class="k">return</span> <span class="n">from_index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>

                <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">test_offset_pos</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)))</span>

                <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">):</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="n">child</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">child</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">):</span>
                        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">child_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">child</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">child_sum</span>

        <span class="k">except</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">sys</span>
            <span class="kn">import</span> <span class="nn">traceback</span>

            <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twice</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len_index&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len_maxes&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;maxes&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len_keys&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;keys&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len_lists&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;lists&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>

            <span class="k">raise</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pyStim 1.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Alexander Tomlinson.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.6.
    </div>
  </body>
</html>